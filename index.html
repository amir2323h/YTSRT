
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Subtitle Generator with Gemini</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Custom scrollbar for webkit browsers */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #2d3748; /* bg-gray-800 */
        }
        textarea::-webkit-scrollbar-thumb {
            background-color: #4a5568; /* bg-gray-600 */
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background-color: #718096; /* bg-gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 flex items-center justify-center min-h-screen font-sans p-4">
    <div class="container mx-auto max-w-4xl w-full">
        <div class="bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 p-6 md:p-10">
            
            <div class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-white flex items-center justify-center gap-3">
                    <i class="fa-solid fa-wand-magic-sparkles text-blue-400"></i>
                    <span>YouTube Subtitle Generator</span>
                </h1>
                <p class="text-gray-400 mt-2">Powered by the Google Gemini API</p>
            </div>
            
            <div class="space-y-6">
                <!-- API Key Section -->
                <div>
                    <label for="api-key" class="font-semibold text-gray-300 mb-2 block">Google Gemini API Key</label>
                    <div class="relative">
                        <i class="fa-solid fa-key absolute left-4 top-1/2 -translate-y-1/2 text-yellow-400"></i>
                        <input type="password" id="api-key" placeholder="Enter your Gemini API Key" class="w-full pl-12 pr-12 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200">
                        <button id="api-key-toggle" type="button" class="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition-colors">
                            <i class="fa-solid fa-eye"></i>
                        </button>
                    </div>
                    <div class="flex items-center mt-2">
                        <input type="checkbox" id="save-api-key" class="h-4 w-4 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-500">
                        <label for="save-api-key" class="ml-2 text-sm text-gray-400">Save API Key</label>
                    </div>
                    <div id="api-key-error" class="text-red-400 text-sm mt-1 hidden">Please enter your Gemini API Key</div>
                </div>
                
                <hr class="border-gray-700">

                <!-- Video Input Section -->
                <div class="space-y-4">
                    <div>
                        <label for="youtube-url" class="font-semibold text-gray-300 mb-2 block">YouTube Video URL</label>
                        <div class="relative">
                            <i class="fa-brands fa-youtube absolute left-4 top-1/2 -translate-y-1/2 text-red-500"></i>
                            <input type="text" id="youtube-url" placeholder="Paste YouTube video URL here" class="w-full pl-12 pr-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200">
                        </div>
                        <div id="url-error" class="text-red-400 text-sm mt-1 hidden">Please enter a valid YouTube URL</div>
                    </div>
                    
                    <div id="duration-container" class="hidden fade-in">
                         <label for="video-duration" class="font-semibold text-gray-300 mb-2 block">Video Duration (MM:SS)</label>
                        <div class="relative">
                            <i class="fa-solid fa-clock absolute left-4 top-1/2 -translate-y-1/2 text-gray-400"></i>
                            <input type="text" id="video-duration" placeholder="e.g., 12:34" class="w-full pl-12 pr-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200">
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Auto-detected. Please edit if incorrect.</p>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="output-language" class="font-semibold text-gray-300 mb-2 block">Output Language</label>
                            <select id="output-language" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200">
                                <!-- Options populated by JavaScript -->
                            </select>
                        </div>
                        <div>
                            <label for="output-format" class="font-semibold text-gray-300 mb-2 block">Output Format</label>
                            <select id="output-format" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200">
                                <option value="srt" selected>SRT (SubRip)</option>
                                <option value="vtt">WebVTT</option>
                                <option value="txt">Plain Text</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Video Preview -->
            <div id="video-preview" class="hidden mt-6 fade-in">
                <label class="font-semibold text-gray-300 mb-2 block">Video Preview</label>
                <div class="aspect-video bg-black rounded-lg overflow-hidden border border-gray-700">
                    <iframe id="video-iframe" class="w-full h-full" frameborder="0" allowfullscreen></iframe>
                </div>
            </div>
            
            <!-- Generate Button -->
            <div class="flex gap-3 mt-8">
                <button id="generate-btn" class="flex-1 bg-blue-600 text-white font-semibold px-6 py-3 rounded-lg hover:bg-blue-700 disabled:bg-blue-800 disabled:cursor-not-allowed focus:outline-none focus:ring-4 focus:ring-blue-500/50 transition-all duration-200 flex items-center justify-center gap-3">
                    <span id="btn-text">Generate Subtitles</span>
                    <svg id="spinner" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <button id="cancel-btn" class="bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center hidden">
                        <i class="fa-solid fa-times text-xs"></i>
                    </button>
                </button>
                <button id="preview-btn" class="bg-gray-600 text-gray-200 font-semibold px-4 py-3 rounded-lg hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-500/50 transition-all duration-200">
                    <i class="fa-solid fa-play w-4"></i>
                </button>
            </div>
            
            <div id="output-container" class="mt-8 hidden fade-in">
                <div id="progress-container" class="mb-4">
                    <div class="w-full bg-gray-700 rounded-full h-2.5">
                        <div id="progress-bar" class="progress-bar bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span id="progress-status">Initializing...</span>
                        <span id="progress-percentage">0%</span>
                    </div>
                </div>
                
                <div id="status-container" class="text-center p-4 rounded-lg mb-4">
                    <p id="status-message" class="font-medium"></p>
                </div>
                
                <div id="results-wrapper" class="hidden fade-in">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-semibold text-white">Generated Subtitles</h3>
                        <div class="flex gap-2">
                            <button id="edit-btn" class="text-sm bg-gray-600 text-gray-200 px-3 py-1 rounded-md hover:bg-gray-500 transition-colors">
                                <i class="fa-solid fa-edit"></i> Edit
                            </button>
                            <button id="timestamp-btn" class="text-sm bg-gray-600 text-gray-200 px-3 py-1 rounded-md hover:bg-gray-500 transition-colors">
                                <i class="fa-solid fa-clock"></i> Adjust
                            </button>
                        </div>
                    </div>
                    
                    <div class="relative">
                        <textarea id="subtitle-output" rows="15" readonly class="w-full p-4 border border-gray-600 bg-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none font-mono text-sm text-gray-200 transition-colors"></textarea>
                        <button id="copy-btn" title="Copy to Clipboard" class="absolute top-3 right-3 bg-gray-700 text-gray-300 px-3 py-1 rounded-md text-xs font-semibold hover:bg-gray-600 transition-colors">
                            <i class="fa-regular fa-copy"></i> Copy
                        </button>
                    </div>
                    
                    <div class="mt-4 flex flex-col sm:flex-row gap-3">
                        <button id="download-btn" class="flex-1 bg-green-600 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-500/50 transition-colors flex items-center justify-center gap-2">
                            <i class="fa-solid fa-download"></i> Download Subtitle File
                        </button>
                        <button id="retry-btn" class="flex-1 bg-gray-600 text-gray-200 font-semibold px-6 py-3 rounded-lg hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-500/50 transition-colors flex items-center justify-center gap-2 hidden">
                            <i class="fa-solid fa-redo"></i> Retry
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Timestamp Adjustment Modal -->
    <div id="timestamp-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 border border-gray-700 rounded-lg p-6 w-full max-w-md">
            <h3 class="text-lg font-semibold text-white mb-4">Adjust Timestamps</h3>
            <div class="space-y-4">
                <div>
                    <label for="offset-seconds" class="block text-sm font-medium text-gray-300 mb-1">Offset (seconds)</label>
                    <input type="number" id="offset-seconds" step="0.1" value="0" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="scale-factor" class="block text-sm font-medium text-gray-300 mb-1">Speed Factor</label>
                    <input type="number" id="scale-factor" step="0.1" min="0.1" max="2.0" value="1.0" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="cancel-timestamp" class="px-4 py-2 bg-gray-600 text-gray-200 rounded-md hover:bg-gray-500 transition-colors">Cancel</button>
                <button id="apply-timestamp" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">Apply</button>
            </div>
        </div>
    </div>
    
    <div id="player" style="position: absolute; top: -9999px; left: -9999px;"></div>
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // --- DOM Element References ---
        const apiKeyInput = document.getElementById('api-key');
        const apiKeyToggleBtn = document.getElementById('api-key-toggle');
        const saveApiKeyCheckbox = document.getElementById('save-api-key');
        const urlInput = document.getElementById('youtube-url');
        const durationContainer = document.getElementById('duration-container');
        const videoDurationInput = document.getElementById('video-duration');
        const outputLanguageSelect = document.getElementById('output-language');
        const outputFormatSelect = document.getElementById('output-format');
        const generateBtn = document.getElementById('generate-btn');
        const previewBtn = document.getElementById('preview-btn');
        const btnText = document.getElementById('btn-text');
        const spinner = document.getElementById('spinner');
        const cancelBtn = document.getElementById('cancel-btn');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const progressPercentage = document.getElementById('progress-percentage');
        const outputContainer = document.getElementById('output-container');
        const statusContainer = document.getElementById('status-container');
        const statusMessage = document.getElementById('status-message');
        const resultsWrapper = document.getElementById('results-wrapper');
        const subtitleOutput = document.getElementById('subtitle-output');
        const copyBtn = document.getElementById('copy-btn');
        const downloadBtn = document.getElementById('download-btn');
        const retryBtn = document.getElementById('retry-btn');
        const editBtn = document.getElementById('edit-btn');
        const timestampBtn = document.getElementById('timestamp-btn');
        const apiKeyError = document.getElementById('api-key-error');
        const urlError = document.getElementById('url-error');
        const videoPreview = document.getElementById('video-preview');
        const videoIframe = document.getElementById('video-iframe');
        const timestampModal = document.getElementById('timestamp-modal');
        const offsetSecondsInput = document.getElementById('offset-seconds');
        const scaleFactorInput = document.getElementById('scale-factor');
        const cancelTimestampBtn = document.getElementById('cancel-timestamp');
        const applyTimestampBtn = document.getElementById('apply-timestamp');
        
        let finalSubtitleContent = '';
        let abortController = null;
        let player;
        let isYTAPILoaded = false;

        const LANGUAGES = [ { value: "auto", text: "Original Video Language" }, { value: "Afrikaans", text: "Afrikaans" }, { value: "Albanian", text: "Albanian" }, { value: "Amharic", text: "Amharic" }, { value: "Arabic", text: "Arabic" }, { value: "Armenian", text: "Armenian" }, { value: "Assamese", text: "Assamese" }, { value: "Aymara", text: "Aymara" }, { value: "Azerbaijani", text: "Azerbaijani" }, { value: "Bambara", text: "Bambara" }, { value: "Basque", text: "Basque" }, { value: "Belarusian", text: "Belarusian" }, { value: "Bengali", text: "Bengali" }, { value: "Bhojpuri", text: "Bhojpuri" }, { value: "Bosnian", text: "Bosnian" }, { value: "Bulgarian", text: "Bulgarian" }, { value: "Catalan", text: "Catalan" }, { value: "Cebuano", text: "Cebuano" }, { value: "Chichewa", text: "Chichewa (Nyanja)" }, { value: "Chinese (Simplified)", text: "Chinese (Simplified)" }, { value: "Chinese (Traditional)", text: "Chinese (Traditional)" }, { value: "Corsican", text: "Corsican" }, { value: "Croatian", text: "Croatian" }, { value: "Czech", text: "Czech" }, { value: "Danish", text: "Danish" }, { value: "Dhivehi", text: "Dhivehi" }, { value: "Dogri", text: "Dogri" }, { value: "Dutch", text: "Dutch" }, { value: "English", text: "English" }, { value: "Esperanto", text: "Esperanto" }, { value: "Estonian", text: "Estonian" }, { value: "Ewe", text: "Ewe" }, { value: "Filipino", text: "Filipino (Tagalog)" }, { value: "Finnish", text: "Finnish" }, { value: "French", text: "French" }, { value: "Frisian", text: "Frisian" }, { value: "Galician", text: "Galician" }, { value: "Georgian", text: "Georgian" }, { value: "German", text: "German" }, { value: "Greek", text: "Greek" }, { value: "Guarani", text: "Guarani" }, { value: "Gujarati", text: "Gujarati" }, { value: "Haitian Creole", text: "Haitian Creole" }, { value: "Hausa", text: "Hausa" }, { value: "Hawaiian", text: "Hawaiian" }, { value: "Hebrew", text: "Hebrew" }, { value: "Hindi", text: "Hindi" }, { value: "Hmong", text: "Hmong" }, { value: "Hungarian", text: "Hungarian" }, { value: "Icelandic", text: "Icelandic" }, { value: "Igbo", text: "Igbo" }, { value: "Ilocano", text: "Ilocano" }, { value: "Indonesian", text: "Indonesian" }, { value: "Irish", text: "Irish" }, { value: "Italian", text: "Italian" }, { value: "Japanese", text: "Japanese" }, { value: "Javanese", text: "Javanese" }, { value: "Kannada", text: "Kannada" }, { value: "Kazakh", text: "Kazakh" }, { value: "Khmer", text: "Khmer" }, { value: "Kinyarwanda", text: "Kinyarwanda" }, { value: "Konkani", text: "Konkani" }, { value: "Korean", text: "Korean" }, { value: "Krio", text: "Krio" }, { value: "Kurdish (Kurmanji)", text: "Kurdish (Kurmanji)" }, { value: "Kurdish (Sorani)", text: "Kurdish (Sorani)" }, { value: "Kyrgyz", text: "Kyrgyz" }, { value: "Lao", text: "Lao" }, { value: "Latin", text: "Latin" }, { value: "Latvian", text: "Latvian" }, { value: "Lingala", text: "Lingala" }, { value: "Lithuanian", text: "Lithuanian" }, { value: "Luganda", text: "Luganda" }, { value: "Luxembourgish", text: "Luxembourgish" }, { value: "Macedonian", text: "Macedonian" }, { value: "Maithili", text: "Maithili" }, { value: "Malagasy", text: "Malagasy" }, { value: "Malay", text: "Malay" }, { value: "Malayalam", text: "Malayalam" }, { value: "Maltese", text: "Maltese" }, { value: "Maori", text: "Maori" }, { value: "Marathi", text: "Marathi" }, { value: "Meiteilon (Manipuri)", text: "Meiteilon (Manipuri)" }, { value: "Mizo", text: "Mizo" }, { value: "Mongolian", text: "Mongolian" }, { value: "Myanmar (Burmese)", text: "Myanmar (Burmese)" }, { value: "Nepali", text: "Nepali" }, { value: "Norwegian", text: "Norwegian" }, { value: "Odia (Oriya)", text: "Odia (Oriya)" }, { value: "Oromo", text: "Oromo" }, { value: "Pashto", text: "Pashto" }, { value: "Persian", text: "Persian (Farsi)" }, { value: "Polish", text: "Polish" }, { value: "Portuguese", text: "Portuguese" }, { value: "Punjabi", text: "Punjabi" }, { value: "Quechua", text: "Quechua" }, { value: "Romanian", text: "Romanian" }, { value: "Russian", text: "Russian" }, { value: "Samoan", text: "Samoan" }, { value: "Sanskrit", text: "Sanskrit" }, { value: "Scots Gaelic", text: "Scots Gaelic" }, { value: "Sepedi", text: "Sepedi" }, { value: "Serbian", text: "Serbian" }, { value: "Sesotho", text: "Sesotho" }, { value: "Shona", text: "Shona" }, { value: "Sindhi", text: "Sindhi" }, { value: "Sinhala", text: "Sinhala" }, { value: "Slovak", text: "Slovak" }, { value: "Slovenian", text: "Slovenian" }, { value: "Somali", text: "Somali" }, { value: "Spanish", text: "Spanish" }, { value: "Sundanese", text: "Sundanese" }, { value: "Swahili", text: "Swahili" }, { value: "Swedish", text: "Swedish" }, { value: "Tajik", text: "Tajik" }, { value: "Tamil", text: "Tamil" }, { value: "Tatar", text: "Tatar" }, { value: "Telugu", text: "Telugu" }, { value: "Thai", text: "Thai" }, { value: "Tigrinya", text: "Tigrinya" }, { value: "Tsonga", text: "Tsonga" }, { value: "Turkish", text: "Turkish" }, { value: "Turkmen", text: "Turkmen" }, { value: "Twi", text: "Twi (Akan)" }, { value: "Ukrainian", text: "Ukrainian" }, { value: "Urdu", text: "Urdu" }, { value: "Uyghur", text: "Uyghur" }, { value: "Uzbek", text: "Uzbek" }, { value: "Vietnamese", text: "Vietnamese" }, { value: "Welsh", text: "Welsh" }, { value: "Xhosa", text: "Xhosa" }, { value: "Yiddish", text: "Yiddish" }, { value: "Yoruba", text: "Yoruba" }, { value: "Zulu", text: "Zulu" }];
        
        function onYouTubeIframeAPIReady() { isYTAPILoaded = true; }
        
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            populateLanguages();
            loadApiKey();
        });
        
        function populateLanguages() {
            LANGUAGES.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.value;
                option.textContent = lang.text;
                outputLanguageSelect.appendChild(option);
            });
            outputLanguageSelect.value = 'English'; // Default to English
        }

        function setupEventListeners() {
            generateBtn.addEventListener('click', handleGeneration);
            previewBtn.addEventListener('click', toggleVideoPreview);
            apiKeyToggleBtn.addEventListener('click', toggleApiKeyVisibility);
            
            cancelBtn.addEventListener('click', () => {
                if (abortController) {
                    abortController.abort();
                    toggleLoading(false);
                    showStatus('Generation was cancelled', 'info');
                }
            });
            
            copyBtn.addEventListener('click', copyToClipboard);
            downloadBtn.addEventListener('click', downloadSubtitleFile);
            retryBtn.addEventListener('click', handleGeneration);
            editBtn.addEventListener('click', toggleEditMode);
            timestampBtn.addEventListener('click', () => timestampModal.classList.remove('hidden'));
            cancelTimestampBtn.addEventListener('click', () => timestampModal.classList.add('hidden'));
            applyTimestampBtn.addEventListener('click', adjustTimestamps);
            
            urlInput.addEventListener('input', validateYouTubeUrl);
            urlInput.addEventListener('change', handleUrlInputChange);
            
            apiKeyInput.addEventListener('input', () => {
                if (apiKeyInput.value.trim()) apiKeyError.classList.add('hidden');
            });
        }

        // --- API Key Management ---
        function toggleApiKeyVisibility() {
            const isPassword = apiKeyInput.type === 'password';
            apiKeyInput.type = isPassword ? 'text' : 'password';
            apiKeyToggleBtn.innerHTML = `<i class="fa-solid ${isPassword ? 'fa-eye-slash' : 'fa-eye'}"></i>`;
        }

        function loadApiKey() {
            const savedKey = localStorage.getItem('geminiApiKey');
            const shouldSave = localStorage.getItem('saveGeminiApiKey') === 'true';
            saveApiKeyCheckbox.checked = shouldSave;
            if (savedKey && shouldSave) {
                apiKeyInput.value = savedKey;
            }
        }

        function saveApiKey() {
            if (saveApiKeyCheckbox.checked) {
                localStorage.setItem('geminiApiKey', apiKeyInput.value.trim());
                localStorage.setItem('saveGeminiApiKey', 'true');
            } else {
                localStorage.removeItem('geminiApiKey');
                localStorage.setItem('saveGeminiApiKey', 'false');
            }
        }
        
        // --- YouTube & Video Handling ---
        function validateYouTubeUrl() {
            const url = urlInput.value.trim();
            const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/)|youtu\.be\/)[\w-]{11}/;
            const isValid = url && youtubeRegex.test(url);
            urlError.classList.toggle('hidden', isValid);
            return isValid;
        }
        
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        function getYouTubeVideoDuration(videoId) {
            if (!isYTAPILoaded) { setTimeout(() => getYouTubeVideoDuration(videoId), 500); return; }
            if (player) { player.destroy(); player = null; }

            player = new YT.Player('player', {
                height: '0', width: '0', videoId: videoId,
                events: {
                    'onReady': (event) => {
                        const duration = event.target.getDuration();
                        if (duration > 0) {
                            videoDurationInput.value = formatDuration(duration);
                            durationContainer.classList.remove('hidden');
                        } else {
                            showStatus('Could not get video duration. It might be a live stream.', 'warning');
                        }
                        event.target.destroy(); player = null;
                    },
                    'onError': () => {
                        showStatus('Could not fetch video details. Check the URL.', 'error');
                        durationContainer.classList.add('hidden');
                        if (player) { player.destroy(); player = null; }
                    }
                }
            });
        }
        
        function handleUrlInputChange() {
            const url = urlInput.value.trim();
            if (validateYouTubeUrl()) {
                const youtubeRegex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([\w-]{11})/;
                const match = url.match(youtubeRegex);
                if (match && match[1]) {
                    durationContainer.classList.add('hidden');
                    getYouTubeVideoDuration(match[1]);
                }
            } else {
                 durationContainer.classList.add('hidden');
            }
        }
        
        function toggleVideoPreview() {
            const url = urlInput.value.trim();
            if (!validateYouTubeUrl()) { showStatus('Please enter a valid YouTube URL first', 'error'); return; }
            
            if (videoPreview.classList.contains('hidden')) {
                const youtubeRegex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([\w-]{11})/;
                const match = url.match(youtubeRegex);
                if (match && match[1]) {
                    videoIframe.src = `https://www.youtube.com/embed/${match[1]}`;
                    videoPreview.classList.remove('hidden');
                    previewBtn.innerHTML = '<i class="fa-solid fa-eye-slash w-4"></i>';
                } else {
                    showStatus('Could not extract video ID from URL', 'error');
                }
            } else {
                videoPreview.classList.add('hidden');
                videoIframe.src = '';
                previewBtn.innerHTML = '<i class="fa-solid fa-play w-4"></i>';
            }
        }
        
        // --- Subtitle Editing & Formatting ---
        function toggleEditMode() {
            const isReadOnly = subtitleOutput.readOnly;
            subtitleOutput.readOnly = !isReadOnly;
            subtitleOutput.classList.toggle('bg-gray-900', isReadOnly);
            subtitleOutput.classList.toggle('bg-gray-700', !isReadOnly);
            editBtn.innerHTML = `<i class="fa-solid ${!isReadOnly ? 'fa-edit' : 'fa-save'}"></i> ${!isReadOnly ? 'Edit' : 'Save'}`;
            editBtn.classList.toggle('bg-gray-600', !isReadOnly);
            editBtn.classList.toggle('text-gray-200', !isReadOnly);
            editBtn.classList.toggle('bg-blue-600', isReadOnly);
            editBtn.classList.toggle('text-white', isReadOnly);

            if (isReadOnly) { // Was readonly, now editable
                subtitleOutput.focus();
            } else { // Was editable, now readonly
                finalSubtitleContent = subtitleOutput.value;
                showStatus('Subtitles updated locally', 'success');
            }
        }
        
        function adjustTimestamps() {
            const offset = parseFloat(offsetSecondsInput.value) || 0;
            const scale = parseFloat(scaleFactorInput.value) || 1.0;
            if (finalSubtitleContent) {
                const adjusted = adjustTimestampsInContent(finalSubtitleContent, offset, scale);
                subtitleOutput.value = adjusted;
                finalSubtitleContent = adjusted;
                showStatus('Timestamps adjusted successfully', 'success');
            }
            timestampModal.classList.add('hidden');
        }
        
        function adjustTimestampsInContent(content, offset, scale) {
            const format = outputFormatSelect.value;
            if (format === 'txt') return content;
            const regex = /(\d{2}:\d{2}:\d{2}[,.]\d{3}) --> (\d{2}:\d{2}:\d{2}[,.]\d{3})/g;
            return content.replace(regex, (m, start, end) => `${adjustTimestamp(start, offset, scale)} --> ${adjustTimestamp(end, offset, scale)}`);
        }
        
        function adjustTimestamp(timestamp, offset, scale) {
            const sep = timestamp.includes(',') ? ',' : '.';
            const [time, ms] = timestamp.split(sep);
            const [h, m, s] = time.split(':').map(Number);
            let totalMs = (h * 3600 + m * 60 + s) * 1000 + parseInt(ms);
            totalMs = Math.max(0, Math.round((totalMs * scale) + (offset * 1000)));
            const newH = Math.floor(totalMs / 3600000);
            const newM = Math.floor((totalMs % 3600000) / 60000);
            const newS = Math.floor((totalMs % 60000) / 1000);
            return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}:${String(newS).padStart(2, '0')}${sep}${String(totalMs % 1000).padStart(3, '0')}`;
        }
        
        function normalizeTimestamp(ts, format = 'srt') {
            const sep = format === 'vtt' ? '.' : ',';
            if (!ts || typeof ts !== 'string') return `00:00:00${sep}000`;
            const parts = ts.split(/[:.,]/).map(p => parseInt(p, 10) || 0);
            let h = 0, m = 0, s = 0, ms = 0;
            if (parts.length === 4) [h, m, s, ms] = parts;
            else if (parts.length === 3) [m, s, ms] = parts;
            else if (parts.length === 2) [m, s] = parts;
            
            let totalMs = h * 3600000 + m * 60000 + s * 1000 + ms;
            const newH = Math.floor(totalMs / 3600000); totalMs %= 3600000;
            const newM = Math.floor(totalMs / 60000); totalMs %= 60000;
            const newS = Math.floor(totalMs / 1000);
            return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}:${String(newS).padStart(2, '0')}${sep}${String(totalMs % 1000).padStart(3, '0')}`;
        }

        function filterAndValidateSubtitles(data) {
            if (!Array.isArray(data)) return [];
            let lastEndTimeMs = -1;
            const timeToMs = (ts) => {
                if (!ts) return 0;
                const sep = ts.includes(',') ? ',' : '.';
                const [time, msStr] = ts.split(sep);
                const [h, m, s] = time.split(':').map(Number);
                return (h * 3600 + m * 60 + s) * 1000 + Number(msStr);
            };

            return data.filter(item => {
                if (!item || typeof item.text !== 'string' || !item.startTime || !item.endTime) return false;
                const startTimeMs = timeToMs(normalizeTimestamp(item.startTime));
                const endTimeMs = timeToMs(normalizeTimestamp(item.endTime));
                if (endTimeMs <= startTimeMs || startTimeMs < lastEndTimeMs - 100) return false;
                lastEndTimeMs = endTimeMs;
                return true;
            });
        }

        function formatSubtitlesFromJSON(data, format) {
            if (!Array.isArray(data)) return "Error: Invalid subtitle data.";
            switch (format) {
                case 'srt': return data.map((item, i) => `${i + 1}\n${normalizeTimestamp(item.startTime, 'srt')} --> ${normalizeTimestamp(item.endTime, 'srt')}\n${(item.text || "").trim()}`).join('\n\n');
                case 'vtt': return "WEBVTT\n\n" + data.map(item => `${normalizeTimestamp(item.startTime, 'vtt')} --> ${normalizeTimestamp(item.endTime, 'vtt')}\n${(item.text || "").trim()}`).join('\n\n');
                case 'txt': return data.map(item => (item.text || "").trim()).join(' ');
                default: return "Unsupported format";
            }
        }

        // --- Main Generation Logic ---
        async function handleGeneration() {
            const apiKey = apiKeyInput.value.trim();
            const youtubeUrl = urlInput.value.trim();
            if (!apiKey) { showStatus('Please provide your Gemini API Key.', 'error'); apiKeyError.classList.remove('hidden'); return; }
            if (!validateYouTubeUrl()) { showStatus('Please enter a valid YouTube URL.', 'error'); return; }
            
            saveApiKey();
            abortController = new AbortController();
            resetUI();
            toggleLoading(true);
            showProgress(0, 'Initializing...');
            showStatus('Sending request to Gemini API...', 'info');
            
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?key=${apiKey}`;
            const Type = { STRING: 'STRING', ARRAY: 'ARRAY', OBJECT: 'OBJECT' };
            const responseSchema = {
                type: Type.ARRAY, items: { type: Type.OBJECT,
                    properties: { startTime: { type: Type.STRING }, endTime: { type: Type.STRING }, text: { type: Type.STRING } },
                    required: ["startTime", "endTime", "text"]
                }
            };
            
            const targetLanguage = outputLanguageSelect.value;
            const duration = videoDurationInput.value.trim();
            let langInstruction;

            if (targetLanguage === 'auto') {
                langInstruction = 'Transcribe the video in its original language.';
            } else {
                langInstruction = `Transcribe the video's audio, then translate the transcription into ${targetLanguage}.`;
            }
            
            const durationInstruction = duration ? `The video duration is ${duration}. Timestamps must not exceed this.` : '';
            
            const promptText = `Expert transcriptionist task: ${langInstruction} ${durationInstruction} Create a precise, time-stamped transcript.
Strict rules:
1.  **NO REPETITION:** Each text segment must be unique and sequential.
2.  **SHORT SEGMENTS:** Keep text segments concise, under 80 characters.
3.  **SEQUENTIAL TIMESTAMPS:** Timestamps must be strictly increasing.
4.  **ACCURATE JSON:** Output a single, valid JSON array of objects matching the schema. The 'text' field must contain the final (translated, if requested) text. No extra text or markdown.`;
            
            const requestBody = {
                contents: [{"role": "user", "parts": [{"fileData": {"mimeType": "video/mp4", "fileUri": youtubeUrl}}, {"text": promptText}]}],
                generationConfig: { "responseMimeType": "application/json", "responseSchema": responseSchema }
            };
            
            try {
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody), signal: abortController.signal });
                if (!response.ok) { const err = await response.json(); throw new Error(`API Error (${response.status}): ${err.error?.message || 'Unknown'}`); }
                
                showProgress(20, 'Receiving response...');
                resultsWrapper.classList.remove('hidden');
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aggregatedJsonString = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    aggregatedJsonString += chunk.replace(/^data: /, '').trim();
                    const progress = Math.min(90, 20 + (aggregatedJsonString.length / 100));
                    showProgress(progress, 'Processing transcription...');
                }
                
                try {
                    const cleanedJson = aggregatedJsonString.replace(/^\[\s*|\s*\]$/g, '');
                    const rawData = JSON.parse(`[${cleanedJson}]`);
                    const subtitleData = filterAndValidateSubtitles(rawData);
                    finalSubtitleContent = formatSubtitlesFromJSON(subtitleData, outputFormatSelect.value);
                    subtitleOutput.value = finalSubtitleContent;
                    showProgress(100, 'Complete!');
                    showStatus('Subtitle generation complete!', 'success');
                } catch (jsonError) {
                    showStatus(`Failed to parse response. Error: ${jsonError.message}`, 'error');
                    subtitleOutput.value = `--- PARSING FAILED ---\n${aggregatedJsonString}`;
                    retryBtn.classList.remove('hidden');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`An error occurred: ${error.message}.`, 'error');
                    retryBtn.classList.remove('hidden');
                }
            } finally {
                toggleLoading(false);
                abortController = null;
            }
        }
        
        // --- UI Helper Functions ---
        function showProgress(percentage, status) {
            progressContainer.classList.remove('hidden');
            progressBar.style.width = `${percentage}%`;
            progressStatus.textContent = status;
            progressPercentage.textContent = `${Math.round(percentage)}%`;
        }
        
        function showStatus(message, type = 'info') {
            outputContainer.classList.remove('hidden');
            statusMessage.textContent = message;
            const classes = {
                success: 'bg-green-900/50 text-green-300 border border-green-700',
                error: 'bg-red-900/50 text-red-400 border border-red-700',
                info: 'bg-blue-900/50 text-blue-300 border border-blue-700',
                warning: 'bg-yellow-900/50 text-yellow-300 border border-yellow-700'
            };
            statusContainer.className = `text-center p-3 rounded-lg mb-4 ${classes[type] || classes.info}`;
        }
        
        function toggleLoading(isLoading) {
            generateBtn.disabled = isLoading;
            btnText.textContent = isLoading ? 'Generating...' : 'Generate Subtitles';
            spinner.classList.toggle('hidden', !isLoading);
            cancelBtn.classList.toggle('hidden', !isLoading);
        }
        
        function resetUI() {
            outputContainer.classList.add('hidden');
            progressContainer.classList.add('hidden');
            resultsWrapper.classList.add('hidden');
            subtitleOutput.value = '';
            finalSubtitleContent = '';
            retryBtn.classList.add('hidden');
            if (!subtitleOutput.readOnly) toggleEditMode();
        }
        
        function copyToClipboard() {
            navigator.clipboard.writeText(subtitleOutput.value).then(() => {
                const original = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
                setTimeout(() => { copyBtn.innerHTML = original; }, 2000);
            }).catch(() => showStatus('Failed to copy', 'error'));
        }
        
        function downloadSubtitleFile() {
            if (!finalSubtitleContent) return;
            const format = outputFormatSelect.value;
            const mime = { srt: 'text/srt', vtt: 'text/vtt', txt: 'text/plain' }[format];
            const blob = new Blob([finalSubtitleContent], { type: `${mime};charset=utf-8` });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const videoId = urlInput.value.trim().match(/(?:v=|be\/|embed\/)([\w-]{11})/)?.[1] || 'subtitles';
            a.download = `subtitles_${videoId}.${format}`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
